---
layout: collection-browser-doc
title: Debugging
category: features
categories_url: features
excerpt: Learn how to debug issues with terragrunt and terraform.
tags: ["DRY", "Use cases", "CLI"]
order: 220
nav_title: Documentation
nav_title_link: /docs/
---

## Debugging

Terragrunt and Terraform usually play well together in helping you
write DRY, re-usable infrastructure. But how do we figure out what
went wrong in the rare case that they _don't_ play well?

Terragrunt provides a debug mode you can access through the `--terragrunt-debug`
command flag. For example you could use it like this to debug an `apply`
that's producing unexpected output:

    $ terragrunt --terragrunt-debug apply

Running this command will do two things for you:
  - Output a file named `terragrunt-debug.tfvars` to your terragrunt working
    directory (the same one containing your `terragrunt.hcl`)
  - Print instructions on how to invoke terraform against the generated file to
    reproduce exactly the same terraform output as you saw when invoking
    `terragrunt`. This will help you to determine where the problem's root cause
    lies.

The flag's goal is to help you determine which of these three major areas is the
root cause of your problem:
  1. Misconfiguration of your infrastructure code.
  2. An error in `terragrunt`.
  3. An error in `terraform`.

Let's run through a few use-cases.  

### Use-case: I use locals or dependencies in terragrunt.hcl, and the terraform output isn't what I expected
 
Consider this file structure for a fictional production environment where we
have configured an application to deploy as many tasks as there are minimum
number of machines in some cluster.

```
    └── live
        └── prod
            └── app
            |   ├── vars.tf
            |   ├── main.tf
            |   ├── outputs.tf
            |   └── terragrunt.hcl
            └── ecs-cluster
                └── outputs.tf
```

The files contain this text (`app/main.tf` and `ecs-cluster/outputs.tf` omitted
for brevity):

```hcl
# app/vars.tf
variable "image_id" {
  type = string
}

variable "num_tasks" {
  type = number
}

# app/outputs.tf
output "task_ids" {
  value = module.app_infra_module.task_ids
}

# app/terragrunt.hcl
locals {
  image_id = "acme/myapp:1"
}

dependency "cluster" {
  config_path = "../ecs-cluster"
}

inputs = {
  image_id = locals.image_id
  num_tasks = dependency.cluster.outputs.cluster_min_size
}
```

You perform a `terragrunt apply`, and find that `outputs.task_ids` has 7
elements, but you know that the cluster only has 4 VMs in it! What's happening?
Let's figure it out. Run this:

    $ terragrunt --terragrunt-debug apply

After applying, you will see this output on standard error

```
[terragrunt] Variables passed to terraform are located in "/Users/erem/live/prod/app/terragrunt-debug.tfvars"
[terragrunt] Run this command to replicate how terraform was invoked:
[terragrunt]     terraform apply -var-file="/Users/erem/live/prod/app/terragrunt-debug.tfvars" "/Users/erem/live/prod/app"
```

Well we may have to do all that, but first let's just take a look at `terragrunt-debug.tfvars`

```hcl
# terragrunt-debug.tfvars

# File generated by terragrunt-debug on 01/01/2020 05:10:16.000Z
# 
# These variables were used by terragrunt's debug mode to invoke terraform.
# To manually invoke terraform using these variables, execute this command:
#     terraform apply -var-file="/Users/erem/live/prod/app/terragrunt-debug.tfvars" "/Users/erem/live/prod/app"
#
image_id  = "acme/myapp:1" # From "locals.image_id"
num_tasks = 7              # From "dependency.cluster.outputs.cluster_min_size" ("../ecs-cluster/outputs.tf")
```

So this gives us the clue -- we expected `num_tasks` to be 4, not 7! Looking into
`ecs-cluster/outputs.tf` we see this text:

```hcl
# ecs-cluster/outputs.tf
output "cluster_min_size" {
  value = module.my_cluster_module.cluster_max_size
}
```

Oops! It says `max` when it should be `min`. If we fix `ecs-cluster/outputs.tf`
we should be golden! We fix the problem in time to take a nice afternoon walk in
the sun.

In this example we've seen how `terragrunt debug` can help us root cause issues
in dependency and local variable resolution.

### Use-case: `terragrunt apply` produces a kernel panic. What's broken?
TODO: not in scope for 1-day project =)

### Use-case: I need more detailed logs to figure out what's happening!
TODO: not in scope for 1-day project =)

### Use-case: apply-all
TODO: not in scope for 1-day project =)

### Progress
We can largely break down this feature into these categories:

  - *Accepting input*. Status: Done
  - *Outputting the TFVARS file*. Status: In Progress
  - *Input attribution*. Status: Not Started
  - *Outputting helpful logs or comments on how to use the tfvars file*. Status: Not Started

As of 04/14/2020, here are notes on each section

#### Progress: Accepting input
Status: Done

This is just about the only part of the feature that is written and tested. The
app now accepts the flag `--terragrunt-debug`, which maps to a boolean flag in
the app that is used to gate whether or not a json flag gets written.

#### Progress: Outputting TFVARS file
Status: In Progress

This is there, but currently broken. I want to document a few design challenges
I found along the way for whoever picks this up next.

First challenge: how to incorporate user-provided `TF_VAR_x` env variables into
the output. Why is this a problem? Well, in addition to specifying values in
`terragrunt.hcl`, we also support forwarding these env variables directly
from the caller's environment to terraform. So then what is the correct behavior
of `terragrunt-debug.tfvars` in the case that the user has `TF_VAR_foo` but also
specifies the input `foo` in `terragrunt.hcl`? Here are some choices:
  - Serialize the user-provided env var `TF_VAR_foo` to `terragrunt-debug.tfvars`
    * Benefits: global reproducibility. Anybody executing terraform against that file would get
      the same output as the original user, since terraform's prioritization
      rules place the file contents at higher priority than the user's own env.
    * Drawbacks: This will mask the terragrunt-interpolated value that the user
      might have actually been trying to debug. This also requires more work
      because we have to martial and interpret those env vars ourselves to
      produce valid hcl and/or json (the difficulty in dealing with TF_VAR_x ->
      JSON was one big stumbling block in doing this project quickly). See 
      https://www.terraform.io/docs/configuration/variables.html#complex-typed-values for
      related discussion
  - Serialize only the interpolated `terragrunt.hcl` value.
    * Benefits: these are the most likely values to be messed up, so we want to see them
    * Drawbacks: fatally, you can't use this one to actually reproduce the call to terraform
      as it was executed by `terragrunt` -- you would need the user's env var for that.
  - Serialize only those interpolated `terragrunt.hcl` values that are not overridden by the
    user's env
    * Benefits: The user themselves can reproduce the call, as long as their env stays the same
      between invocations of terragrunt and terraform.
    * Drawbacks: Not globally reproducible. Violates the principle of least surprise
      -- depending on their use-case the user will expect to see not only what it
      takes to reproduce the terraform, but also what the world looked like according to terragrunt.
      This is however the version that is currently implemented (brokenly).
  - Serialize both, but comment out the interpolated value as overridden by the user's env. This
    one has all the benefits of the other approaches and none of their weaknesses except that it
    would take longer to implement, and is not doable in json (which I fell back on for time sake)
    due to lack of commenting. I recommend doing this approach for whoever picks up the torch.

Second challenge (the cause of the current bug). Even in single-module calls, an
invocation to `terragrunt` can involve several calls to `terraform`: one call to
the user's target command and one `terraform init`. The two follow the same call
path, and some state carries over between the first and the second: the
TerragruntOptions.Env map in the second invocation remains updated to reflect
the resolved input values from the first. Why does that matter? Since the
current implementation of this feature tries to grab only the subset of
`terragrunt.hcl` inputs that were not duplicated in the user's env (see previous
challenge), the Debug file is first written with all the correct values (for the
`terraform init`), and then rewritten with an empty object, since after the
first command all input variables have been written into the env map. Since this
approach kind of sucks anyways, I recommend just switching to the "serialize
both" resolution strategy from challenge 1 and this problem should puff into the
mist.

We also need significant testing, and particularly testing on the _-all_
variants of the command, though I believe the file will naturally end up
serializing to the correct location as written.

#### Progress: Input Attribution
Status: Not started

This is the part of the feature where we share with the user "oh by the way,
this input was resolved from this a/b/terragrunt.hcl". 

I did not get to touch this beyond general thoughts on how it could be
accomplished, which follow:

Currently, `terragrunt.hcl` input resolution happens in
`config.go::ParseConfigString`, and its goal is to resolve a valid
`TerragruntConfig`. `TerragruntConfig` has a property `Inputs` that is a map
from string to json-marshallable value.

My proposal would be to instead make `Inputs` into a map from string to tuple of
(value, metadata) where the metadata for example contains information about the
source file. The source file can be easily threaded through the call stack from
interpreted `ParseConfigString`. Then, without changing any of the resolution
logic we would end up with the correct attribution in the `Inputs` property when
it's time to write the debug file. Still figuring out how locals would fit into
this scheme.

#### Progress: Outputting helpful logs or comments on how to use the tfvars file
Status: Not started

Didn't get a chance to even think much about this one honestly =/
